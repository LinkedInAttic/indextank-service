#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class IndexerStatus:
  started = 0
  recovering = 1
  ready = 2
  error = 3

  _VALUES_TO_NAMES = {
    0: "started",
    1: "recovering",
    2: "ready",
    3: "error",
  }

  _NAMES_TO_VALUES = {
    "started": 0,
    "recovering": 1,
    "ready": 2,
    "error": 3,
  }

class PageType:
  initial = 0
  optimized = 1
  index = 2
  live = 3

  _VALUES_TO_NAMES = {
    0: "initial",
    1: "optimized",
    2: "index",
    3: "live",
  }

  _NAMES_TO_VALUES = {
    "initial": 0,
    "optimized": 1,
    "index": 2,
    "live": 3,
  }


class Document:
  """
  Attributes:
   - fields
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'fields', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, fields=None,):
    self.fields = fields

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.fields = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.fields[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Document')
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fields))
      for kiter7,viter8 in self.fields.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ResultSet:
  """
  Attributes:
   - status
   - matches
   - docs
   - facets
   - didyoumean
   - categories
   - variables
   - scores
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'status', None, None, ), # 1
    (2, TType.I32, 'matches', None, None, ), # 2
    (3, TType.LIST, 'docs', (TType.MAP,(TType.STRING,None,TType.STRING,None)), None, ), # 3
    (4, TType.MAP, 'facets', (TType.STRING,None,TType.MAP,(TType.STRING,None,TType.I32,None)), {
    }, ), # 4
    (5, TType.STRING, 'didyoumean', None, None, ), # 5
    (6, TType.LIST, 'categories', (TType.MAP,(TType.STRING,None,TType.STRING,None)), [
    ], ), # 6
    (7, TType.LIST, 'variables', (TType.MAP,(TType.I32,None,TType.DOUBLE,None)), [
    ], ), # 7
    (8, TType.LIST, 'scores', (TType.DOUBLE,None), None, ), # 8
  )

  def __init__(self, status=None, matches=None, docs=None, facets=thrift_spec[4][4], didyoumean=None, categories=thrift_spec[6][4], variables=thrift_spec[7][4], scores=None,):
    self.status = status
    self.matches = matches
    self.docs = docs
    if facets is self.thrift_spec[4][4]:
      facets = {
    }
    self.facets = facets
    self.didyoumean = didyoumean
    if categories is self.thrift_spec[6][4]:
      categories = [
    ]
    self.categories = categories
    if variables is self.thrift_spec[7][4]:
      variables = [
    ]
    self.variables = variables
    self.scores = scores

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.matches = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.docs = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = {}
            (_ktype16, _vtype17, _size15 ) = iprot.readMapBegin() 
            for _i19 in xrange(_size15):
              _key20 = iprot.readString();
              _val21 = iprot.readString();
              _elem14[_key20] = _val21
            iprot.readMapEnd()
            self.docs.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.facets = {}
          (_ktype23, _vtype24, _size22 ) = iprot.readMapBegin() 
          for _i26 in xrange(_size22):
            _key27 = iprot.readString();
            _val28 = {}
            (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
            for _i33 in xrange(_size29):
              _key34 = iprot.readString();
              _val35 = iprot.readI32();
              _val28[_key34] = _val35
            iprot.readMapEnd()
            self.facets[_key27] = _val28
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.didyoumean = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.categories = []
          (_etype39, _size36) = iprot.readListBegin()
          for _i40 in xrange(_size36):
            _elem41 = {}
            (_ktype43, _vtype44, _size42 ) = iprot.readMapBegin() 
            for _i46 in xrange(_size42):
              _key47 = iprot.readString();
              _val48 = iprot.readString();
              _elem41[_key47] = _val48
            iprot.readMapEnd()
            self.categories.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.variables = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = {}
            (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin() 
            for _i59 in xrange(_size55):
              _key60 = iprot.readI32();
              _val61 = iprot.readDouble();
              _elem54[_key60] = _val61
            iprot.readMapEnd()
            self.variables.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.scores = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = iprot.readDouble();
            self.scores.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ResultSet')
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 1)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.matches != None:
      oprot.writeFieldBegin('matches', TType.I32, 2)
      oprot.writeI32(self.matches)
      oprot.writeFieldEnd()
    if self.docs != None:
      oprot.writeFieldBegin('docs', TType.LIST, 3)
      oprot.writeListBegin(TType.MAP, len(self.docs))
      for iter68 in self.docs:
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter68))
        for kiter69,viter70 in iter68.items():
          oprot.writeString(kiter69)
          oprot.writeString(viter70)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.facets != None:
      oprot.writeFieldBegin('facets', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.facets))
      for kiter71,viter72 in self.facets.items():
        oprot.writeString(kiter71)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter72))
        for kiter73,viter74 in viter72.items():
          oprot.writeString(kiter73)
          oprot.writeI32(viter74)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.didyoumean != None:
      oprot.writeFieldBegin('didyoumean', TType.STRING, 5)
      oprot.writeString(self.didyoumean)
      oprot.writeFieldEnd()
    if self.categories != None:
      oprot.writeFieldBegin('categories', TType.LIST, 6)
      oprot.writeListBegin(TType.MAP, len(self.categories))
      for iter75 in self.categories:
        oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter75))
        for kiter76,viter77 in iter75.items():
          oprot.writeString(kiter76)
          oprot.writeString(viter77)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.variables != None:
      oprot.writeFieldBegin('variables', TType.LIST, 7)
      oprot.writeListBegin(TType.MAP, len(self.variables))
      for iter78 in self.variables:
        oprot.writeMapBegin(TType.I32, TType.DOUBLE, len(iter78))
        for kiter79,viter80 in iter78.items():
          oprot.writeI32(kiter79)
          oprot.writeDouble(viter80)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.scores != None:
      oprot.writeFieldBegin('scores', TType.LIST, 8)
      oprot.writeListBegin(TType.DOUBLE, len(self.scores))
      for iter81 in self.scores:
        oprot.writeDouble(iter81)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SearcherStats:
  """
  Attributes:
   - status
   - mean_qps
   - max_qps
   - top10
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'status', None, None, ), # 1
    (2, TType.DOUBLE, 'mean_qps', None, None, ), # 2
    (3, TType.DOUBLE, 'max_qps', None, None, ), # 3
    (4, TType.LIST, 'top10', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, status=None, mean_qps=None, max_qps=None, top10=None,):
    self.status = status
    self.mean_qps = mean_qps
    self.max_qps = max_qps
    self.top10 = top10

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.mean_qps = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.max_qps = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.top10 = []
          (_etype85, _size82) = iprot.readListBegin()
          for _i86 in xrange(_size82):
            _elem87 = iprot.readString();
            self.top10.append(_elem87)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SearcherStats')
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 1)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.mean_qps != None:
      oprot.writeFieldBegin('mean_qps', TType.DOUBLE, 2)
      oprot.writeDouble(self.mean_qps)
      oprot.writeFieldEnd()
    if self.max_qps != None:
      oprot.writeFieldBegin('max_qps', TType.DOUBLE, 3)
      oprot.writeDouble(self.max_qps)
      oprot.writeFieldEnd()
    if self.top10 != None:
      oprot.writeFieldBegin('top10', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.top10))
      for iter88 in self.top10:
        oprot.writeString(iter88)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WorkerMountStats:
  """
  Attributes:
   - fs_sizes
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'fs_sizes', (TType.STRING,None,TType.LIST,(TType.I32,None)), None, ), # 1
  )

  def __init__(self, fs_sizes=None,):
    self.fs_sizes = fs_sizes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.fs_sizes = {}
          (_ktype90, _vtype91, _size89 ) = iprot.readMapBegin() 
          for _i93 in xrange(_size89):
            _key94 = iprot.readString();
            _val95 = []
            (_etype99, _size96) = iprot.readListBegin()
            for _i100 in xrange(_size96):
              _elem101 = iprot.readI32();
              _val95.append(_elem101)
            iprot.readListEnd()
            self.fs_sizes[_key94] = _val95
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WorkerMountStats')
    if self.fs_sizes != None:
      oprot.writeFieldBegin('fs_sizes', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.fs_sizes))
      for kiter102,viter103 in self.fs_sizes.items():
        oprot.writeString(kiter102)
        oprot.writeListBegin(TType.I32, len(viter103))
        for iter104 in viter103:
          oprot.writeI32(iter104)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class WorkerLoadStats:
  """
  Attributes:
   - one_minute_load
   - five_minutes_load
   - fifteen_minutes_load
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'one_minute_load', None, None, ), # 1
    (2, TType.DOUBLE, 'five_minutes_load', None, None, ), # 2
    (3, TType.DOUBLE, 'fifteen_minutes_load', None, None, ), # 3
  )

  def __init__(self, one_minute_load=None, five_minutes_load=None, fifteen_minutes_load=None,):
    self.one_minute_load = one_minute_load
    self.five_minutes_load = five_minutes_load
    self.fifteen_minutes_load = fifteen_minutes_load

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.one_minute_load = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.five_minutes_load = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.fifteen_minutes_load = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('WorkerLoadStats')
    if self.one_minute_load != None:
      oprot.writeFieldBegin('one_minute_load', TType.DOUBLE, 1)
      oprot.writeDouble(self.one_minute_load)
      oprot.writeFieldEnd()
    if self.five_minutes_load != None:
      oprot.writeFieldBegin('five_minutes_load', TType.DOUBLE, 2)
      oprot.writeDouble(self.five_minutes_load)
      oprot.writeFieldEnd()
    if self.fifteen_minutes_load != None:
      oprot.writeFieldBegin('fifteen_minutes_load', TType.DOUBLE, 3)
      oprot.writeDouble(self.fifteen_minutes_load)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexStats:
  """
  Attributes:
   - used_disk
   - used_mem
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.I32, 'used_disk', None, None, ), # 2
    (3, TType.I32, 'used_mem', None, None, ), # 3
  )

  def __init__(self, used_disk=None, used_mem=None,):
    self.used_disk = used_disk
    self.used_mem = used_mem

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.I32:
          self.used_disk = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.used_mem = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexStats')
    if self.used_disk != None:
      oprot.writeFieldBegin('used_disk', TType.I32, 2)
      oprot.writeI32(self.used_disk)
      oprot.writeFieldEnd()
    if self.used_mem != None:
      oprot.writeFieldBegin('used_mem', TType.I32, 3)
      oprot.writeI32(self.used_mem)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RangeFilter:
  """
  Attributes:
   - key
   - floor
   - no_floor
   - ceil
   - no_ceil
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'key', None, None, ), # 1
    (2, TType.DOUBLE, 'floor', None, None, ), # 2
    (3, TType.BOOL, 'no_floor', None, None, ), # 3
    (4, TType.DOUBLE, 'ceil', None, None, ), # 4
    (5, TType.BOOL, 'no_ceil', None, None, ), # 5
  )

  def __init__(self, key=None, floor=None, no_floor=None, ceil=None, no_ceil=None,):
    self.key = key
    self.floor = floor
    self.no_floor = no_floor
    self.ceil = ceil
    self.no_ceil = no_ceil

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.key = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.floor = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.no_floor = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.ceil = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.no_ceil = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RangeFilter')
    if self.key != None:
      oprot.writeFieldBegin('key', TType.I32, 1)
      oprot.writeI32(self.key)
      oprot.writeFieldEnd()
    if self.floor != None:
      oprot.writeFieldBegin('floor', TType.DOUBLE, 2)
      oprot.writeDouble(self.floor)
      oprot.writeFieldEnd()
    if self.no_floor != None:
      oprot.writeFieldBegin('no_floor', TType.BOOL, 3)
      oprot.writeBool(self.no_floor)
      oprot.writeFieldEnd()
    if self.ceil != None:
      oprot.writeFieldBegin('ceil', TType.DOUBLE, 4)
      oprot.writeDouble(self.ceil)
      oprot.writeFieldEnd()
    if self.no_ceil != None:
      oprot.writeFieldBegin('no_ceil', TType.BOOL, 5)
      oprot.writeBool(self.no_ceil)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexerStats:
  """
  Attributes:
   - status
   - documents
   - size
   - dipm
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'status', None, None, ), # 1
    (2, TType.I32, 'documents', None, None, ), # 2
    (3, TType.I32, 'size', None, None, ), # 3
    (4, TType.DOUBLE, 'dipm', None, None, ), # 4
  )

  def __init__(self, status=None, documents=None, size=None, dipm=None,):
    self.status = status
    self.documents = documents
    self.size = size
    self.dipm = dipm

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.documents = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.size = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.dipm = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexerStats')
    if self.status != None:
      oprot.writeFieldBegin('status', TType.STRING, 1)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    if self.documents != None:
      oprot.writeFieldBegin('documents', TType.I32, 2)
      oprot.writeI32(self.documents)
      oprot.writeFieldEnd()
    if self.size != None:
      oprot.writeFieldBegin('size', TType.I32, 3)
      oprot.writeI32(self.size)
      oprot.writeFieldEnd()
    if self.dipm != None:
      oprot.writeFieldBegin('dipm', TType.DOUBLE, 4)
      oprot.writeDouble(self.dipm)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CategoryFilter:
  """
  Attributes:
   - category
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'category', None, None, ), # 1
    (2, TType.STRING, 'value', None, None, ), # 2
  )

  def __init__(self, category=None, value=None,):
    self.category = category
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.category = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CategoryFilter')
    if self.category != None:
      oprot.writeFieldBegin('category', TType.STRING, 1)
      oprot.writeString(self.category)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexInfo:
  """
  Attributes:
   - code
   - name
   - account_email
   - document_count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'code', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'account_email', None, None, ), # 3
    (4, TType.I32, 'document_count', None, None, ), # 4
  )

  def __init__(self, code=None, name=None, account_email=None, document_count=None,):
    self.code = code
    self.name = name
    self.account_email = account_email
    self.document_count = document_count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.account_email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.document_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexInfo')
    if self.code != None:
      oprot.writeFieldBegin('code', TType.STRING, 1)
      oprot.writeString(self.code)
      oprot.writeFieldEnd()
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.account_email != None:
      oprot.writeFieldBegin('account_email', TType.STRING, 3)
      oprot.writeString(self.account_email)
      oprot.writeFieldEnd()
    if self.document_count != None:
      oprot.writeFieldBegin('document_count', TType.I32, 4)
      oprot.writeI32(self.document_count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndextankException(Exception):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndextankException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidQueryException(Exception):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidQueryException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class MissingQueryVariableException(Exception):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('MissingQueryVariableException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NebuException(Exception):
  """
  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NebuException')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogRecord:
  """
  Attributes:
   - id
   - timestamp_ms
   - index_code
   - docid
   - deleted
   - fields
   - variables
   - categories
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'id', None, None, ), # 1
    (2, TType.I64, 'timestamp_ms', None, None, ), # 2
    (3, TType.STRING, 'index_code', None, None, ), # 3
    (4, TType.STRING, 'docid', None, None, ), # 4
    (5, TType.BOOL, 'deleted', None, None, ), # 5
    (6, TType.MAP, 'fields', (TType.STRING,None,TType.STRING,None), None, ), # 6
    (7, TType.MAP, 'variables', (TType.I32,None,TType.DOUBLE,None), None, ), # 7
    (8, TType.MAP, 'categories', (TType.STRING,None,TType.STRING,None), None, ), # 8
  )

  def __init__(self, id=None, timestamp_ms=None, index_code=None, docid=None, deleted=None, fields=None, variables=None, categories=None,):
    self.id = id
    self.timestamp_ms = timestamp_ms
    self.index_code = index_code
    self.docid = docid
    self.deleted = deleted
    self.fields = fields
    self.variables = variables
    self.categories = categories

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.id = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp_ms = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.index_code = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.docid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.deleted = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.fields = {}
          (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin() 
          for _i109 in xrange(_size105):
            _key110 = iprot.readString();
            _val111 = iprot.readString();
            self.fields[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.variables = {}
          (_ktype113, _vtype114, _size112 ) = iprot.readMapBegin() 
          for _i116 in xrange(_size112):
            _key117 = iprot.readI32();
            _val118 = iprot.readDouble();
            self.variables[_key117] = _val118
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.categories = {}
          (_ktype120, _vtype121, _size119 ) = iprot.readMapBegin() 
          for _i123 in xrange(_size119):
            _key124 = iprot.readString();
            _val125 = iprot.readString();
            self.categories[_key124] = _val125
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogRecord')
    if self.id != None:
      oprot.writeFieldBegin('id', TType.I64, 1)
      oprot.writeI64(self.id)
      oprot.writeFieldEnd()
    if self.timestamp_ms != None:
      oprot.writeFieldBegin('timestamp_ms', TType.I64, 2)
      oprot.writeI64(self.timestamp_ms)
      oprot.writeFieldEnd()
    if self.index_code != None:
      oprot.writeFieldBegin('index_code', TType.STRING, 3)
      oprot.writeString(self.index_code)
      oprot.writeFieldEnd()
    if self.docid != None:
      oprot.writeFieldBegin('docid', TType.STRING, 4)
      oprot.writeString(self.docid)
      oprot.writeFieldEnd()
    if self.deleted != None:
      oprot.writeFieldBegin('deleted', TType.BOOL, 5)
      oprot.writeBool(self.deleted)
      oprot.writeFieldEnd()
    if self.fields != None:
      oprot.writeFieldBegin('fields', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fields))
      for kiter126,viter127 in self.fields.items():
        oprot.writeString(kiter126)
        oprot.writeString(viter127)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.variables != None:
      oprot.writeFieldBegin('variables', TType.MAP, 7)
      oprot.writeMapBegin(TType.I32, TType.DOUBLE, len(self.variables))
      for kiter128,viter129 in self.variables.items():
        oprot.writeI32(kiter128)
        oprot.writeDouble(viter129)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.categories != None:
      oprot.writeFieldBegin('categories', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.categories))
      for kiter130,viter131 in self.categories.items():
        oprot.writeString(kiter130)
        oprot.writeString(viter131)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogPageToken:
  """
  Attributes:
   - type
   - timestamp
   - file_position
   - next_type
   - next_timestamp
   - OBSOLETE_1
   - OBSOLETE_2
   - OBSOLETE_3
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None,     0, ), # 1
    (2, TType.I64, 'timestamp', None, None, ), # 2
    (3, TType.I64, 'OBSOLETE_1', None, None, ), # 3
    (4, TType.STRING, 'OBSOLETE_2', None, None, ), # 4
    (5, TType.I64, 'file_position', None, None, ), # 5
    (6, TType.BOOL, 'OBSOLETE_3', None, None, ), # 6
    (7, TType.I32, 'next_type', None, None, ), # 7
    (8, TType.I64, 'next_timestamp', None, None, ), # 8
  )

  def __init__(self, type=thrift_spec[1][4], timestamp=None, file_position=None, next_type=None, next_timestamp=None, OBSOLETE_1=None, OBSOLETE_2=None, OBSOLETE_3=None,):
    self.type = type
    self.timestamp = timestamp
    self.file_position = file_position
    self.next_type = next_type
    self.next_timestamp = next_timestamp
    self.OBSOLETE_1 = OBSOLETE_1
    self.OBSOLETE_2 = OBSOLETE_2
    self.OBSOLETE_3 = OBSOLETE_3

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.file_position = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.next_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.next_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.OBSOLETE_1 = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.OBSOLETE_2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.OBSOLETE_3 = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogPageToken')
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 2)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.OBSOLETE_1 != None:
      oprot.writeFieldBegin('OBSOLETE_1', TType.I64, 3)
      oprot.writeI64(self.OBSOLETE_1)
      oprot.writeFieldEnd()
    if self.OBSOLETE_2 != None:
      oprot.writeFieldBegin('OBSOLETE_2', TType.STRING, 4)
      oprot.writeString(self.OBSOLETE_2)
      oprot.writeFieldEnd()
    if self.file_position != None:
      oprot.writeFieldBegin('file_position', TType.I64, 5)
      oprot.writeI64(self.file_position)
      oprot.writeFieldEnd()
    if self.OBSOLETE_3 != None:
      oprot.writeFieldBegin('OBSOLETE_3', TType.BOOL, 6)
      oprot.writeBool(self.OBSOLETE_3)
      oprot.writeFieldEnd()
    if self.next_type != None:
      oprot.writeFieldBegin('next_type', TType.I32, 7)
      oprot.writeI32(self.next_type)
      oprot.writeFieldEnd()
    if self.next_timestamp != None:
      oprot.writeFieldBegin('next_timestamp', TType.I64, 8)
      oprot.writeI64(self.next_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogBatch:
  """
  Attributes:
   - records
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'records', (TType.STRUCT,(LogRecord, LogRecord.thrift_spec)), None, ), # 1
  )

  def __init__(self, records=None,):
    self.records = records

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.records = []
          (_etype135, _size132) = iprot.readListBegin()
          for _i136 in xrange(_size132):
            _elem137 = LogRecord()
            _elem137.read(iprot)
            self.records.append(_elem137)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogBatch')
    if self.records != None:
      oprot.writeFieldBegin('records', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.records))
      for iter138 in self.records:
        iter138.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LogPage:
  """
  Attributes:
   - batch
   - next_page_token
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'batch', (LogBatch, LogBatch.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'next_page_token', (LogPageToken, LogPageToken.thrift_spec), None, ), # 2
  )

  def __init__(self, batch=None, next_page_token=None,):
    self.batch = batch
    self.next_page_token = next_page_token

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.batch = LogBatch()
          self.batch.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.next_page_token = LogPageToken()
          self.next_page_token.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LogPage')
    if self.batch != None:
      oprot.writeFieldBegin('batch', TType.STRUCT, 1)
      self.batch.write(oprot)
      oprot.writeFieldEnd()
    if self.next_page_token != None:
      oprot.writeFieldBegin('next_page_token', TType.STRUCT, 2)
      self.next_page_token.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SegmentInfo:
  """
  Attributes:
   - timestamp
   - end_timestamp
   - valid_length
   - actual_length
   - record_count
   - sorted
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'timestamp', None, None, ), # 1
    (2, TType.I64, 'end_timestamp', None, None, ), # 2
    (3, TType.I64, 'valid_length', None, None, ), # 3
    (4, TType.I64, 'actual_length', None, None, ), # 4
    (5, TType.I32, 'record_count', None, None, ), # 5
    (6, TType.BOOL, 'sorted', None, None, ), # 6
  )

  def __init__(self, timestamp=None, end_timestamp=None, valid_length=None, actual_length=None, record_count=None, sorted=None,):
    self.timestamp = timestamp
    self.end_timestamp = end_timestamp
    self.valid_length = valid_length
    self.actual_length = actual_length
    self.record_count = record_count
    self.sorted = sorted

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.end_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.valid_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.actual_length = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.record_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.sorted = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SegmentInfo')
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 1)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.end_timestamp != None:
      oprot.writeFieldBegin('end_timestamp', TType.I64, 2)
      oprot.writeI64(self.end_timestamp)
      oprot.writeFieldEnd()
    if self.valid_length != None:
      oprot.writeFieldBegin('valid_length', TType.I64, 3)
      oprot.writeI64(self.valid_length)
      oprot.writeFieldEnd()
    if self.actual_length != None:
      oprot.writeFieldBegin('actual_length', TType.I64, 4)
      oprot.writeI64(self.actual_length)
      oprot.writeFieldEnd()
    if self.record_count != None:
      oprot.writeFieldBegin('record_count', TType.I32, 5)
      oprot.writeI32(self.record_count)
      oprot.writeFieldEnd()
    if self.sorted != None:
      oprot.writeFieldBegin('sorted', TType.BOOL, 6)
      oprot.writeBool(self.sorted)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RawLogInfo:
  """
  Attributes:
   - undealt_segments
   - dealer_next_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'undealt_segments', (TType.STRUCT,(SegmentInfo, SegmentInfo.thrift_spec)), None, ), # 1
    (2, TType.I64, 'dealer_next_timestamp', None, None, ), # 2
  )

  def __init__(self, undealt_segments=None, dealer_next_timestamp=None,):
    self.undealt_segments = undealt_segments
    self.dealer_next_timestamp = dealer_next_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.undealt_segments = []
          (_etype142, _size139) = iprot.readListBegin()
          for _i143 in xrange(_size139):
            _elem144 = SegmentInfo()
            _elem144.read(iprot)
            self.undealt_segments.append(_elem144)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.dealer_next_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RawLogInfo')
    if self.undealt_segments != None:
      oprot.writeFieldBegin('undealt_segments', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.undealt_segments))
      for iter145 in self.undealt_segments:
        iter145.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.dealer_next_timestamp != None:
      oprot.writeFieldBegin('dealer_next_timestamp', TType.I64, 2)
      oprot.writeI64(self.dealer_next_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IndexLogInfo:
  """
  Attributes:
   - optimized_segments
   - sorted_segments
   - unsorted_segments
   - optimized_record_count
   - unoptimized_record_count
   - unoptimized_segments
   - last_optimization_timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'optimized_segments', (TType.STRUCT,(SegmentInfo, SegmentInfo.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'sorted_segments', (TType.STRUCT,(SegmentInfo, SegmentInfo.thrift_spec)), None, ), # 2
    (3, TType.LIST, 'unsorted_segments', (TType.STRUCT,(SegmentInfo, SegmentInfo.thrift_spec)), None, ), # 3
    (4, TType.I64, 'optimized_record_count', None, None, ), # 4
    (5, TType.I64, 'unoptimized_record_count', None, None, ), # 5
    (6, TType.I32, 'unoptimized_segments', None, None, ), # 6
    (7, TType.I64, 'last_optimization_timestamp', None, None, ), # 7
  )

  def __init__(self, optimized_segments=None, sorted_segments=None, unsorted_segments=None, optimized_record_count=None, unoptimized_record_count=None, unoptimized_segments=None, last_optimization_timestamp=None,):
    self.optimized_segments = optimized_segments
    self.sorted_segments = sorted_segments
    self.unsorted_segments = unsorted_segments
    self.optimized_record_count = optimized_record_count
    self.unoptimized_record_count = unoptimized_record_count
    self.unoptimized_segments = unoptimized_segments
    self.last_optimization_timestamp = last_optimization_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.optimized_segments = []
          (_etype149, _size146) = iprot.readListBegin()
          for _i150 in xrange(_size146):
            _elem151 = SegmentInfo()
            _elem151.read(iprot)
            self.optimized_segments.append(_elem151)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.sorted_segments = []
          (_etype155, _size152) = iprot.readListBegin()
          for _i156 in xrange(_size152):
            _elem157 = SegmentInfo()
            _elem157.read(iprot)
            self.sorted_segments.append(_elem157)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.unsorted_segments = []
          (_etype161, _size158) = iprot.readListBegin()
          for _i162 in xrange(_size158):
            _elem163 = SegmentInfo()
            _elem163.read(iprot)
            self.unsorted_segments.append(_elem163)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.optimized_record_count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.unoptimized_record_count = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.unoptimized_segments = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.last_optimization_timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IndexLogInfo')
    if self.optimized_segments != None:
      oprot.writeFieldBegin('optimized_segments', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.optimized_segments))
      for iter164 in self.optimized_segments:
        iter164.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sorted_segments != None:
      oprot.writeFieldBegin('sorted_segments', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.sorted_segments))
      for iter165 in self.sorted_segments:
        iter165.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unsorted_segments != None:
      oprot.writeFieldBegin('unsorted_segments', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.unsorted_segments))
      for iter166 in self.unsorted_segments:
        iter166.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optimized_record_count != None:
      oprot.writeFieldBegin('optimized_record_count', TType.I64, 4)
      oprot.writeI64(self.optimized_record_count)
      oprot.writeFieldEnd()
    if self.unoptimized_record_count != None:
      oprot.writeFieldBegin('unoptimized_record_count', TType.I64, 5)
      oprot.writeI64(self.unoptimized_record_count)
      oprot.writeFieldEnd()
    if self.unoptimized_segments != None:
      oprot.writeFieldBegin('unoptimized_segments', TType.I32, 6)
      oprot.writeI32(self.unoptimized_segments)
      oprot.writeFieldEnd()
    if self.last_optimization_timestamp != None:
      oprot.writeFieldBegin('last_optimization_timestamp', TType.I64, 7)
      oprot.writeI64(self.last_optimization_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class QueueScore:
  """
  Attributes:
   - priority
   - score
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'priority', None, None, ), # 1
    (2, TType.DOUBLE, 'score', None, None, ), # 2
  )

  def __init__(self, priority=None, score=None,):
    self.priority = priority
    self.score = score

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.score = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('QueueScore')
    if self.priority != None:
      oprot.writeFieldBegin('priority', TType.I32, 1)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.score != None:
      oprot.writeFieldBegin('score', TType.DOUBLE, 2)
      oprot.writeDouble(self.score)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()
    def validate(self):
      return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
